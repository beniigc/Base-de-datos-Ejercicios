/* 3. Cree el/los objetos de base de datos necesarios para corregir la tabla empleado
en caso que sea necesario. Se sabe que debería existir un único gerente general
(debería ser el único empleado sin jefe). Si detecta que hay más de un empleado
sin jefe deberá elegir entre ellos el gerente general, el cual será seleccionado por
mayor salario. Si hay más de uno se seleccionara el de mayor antigüedad en la
empresa. Al finalizar la ejecución del objeto la tabla deberá cumplir con la regla
de un único empleado sin jefe (el gerente general) y deberá retornar la cantidad
de empleados que había sin jefe antes de la ejecución. */

select * from Empleado 

Create Procedure Ej3Transact @cantidad Int OUTPUT
AS
BEGIN
select @cantidad = count(*) 
		From Empleado
		where empl_jefe is null
if @cantidad > 1
	begin
		update Empleado	
			set empl_jefe = (select top 1 Empl_codigo From Empleado
								where empl_jefe is null
								order by empl_salario, empl_ingreso)
			where empl_jefe is null and 
			  empl_codigo not in (SELECT TOP 1 EMPL_CODIGO 
								  FROM EMPLEADO  
								  where empl_jefe is null 
								  ORDER BY empl_salario DESC, empl_ingreso ASC) /* PORQUE SINO UPDATEARIA AL QUE ES TAMBIEN */
	end
end
go

BEGIN
declare @cantidadEmpl int
exec dbo.Ej3Transact @cantidadEmpl output
print @cantidadEmpl
end 
go


/* 4. Cree el/los objetos de base de datos necesarios para actualizar la columna de
empleado empl_comision con la sumatoria del total de lo vendido por ese
empleado a lo largo del último año. Se deberá retornar el código del vendedor
que más vendió (en monto) a lo largo del último año. */

select * FROM Empleado
select * FROM Factura

Create Procedure Ej4Transact @mejorEmpleado int OUTPUT
AS
BEGIN
	UPDATE Empleado
    SET empl_comision = ISNULL((SELECT SUM(fact_total)
								FROM Factura 
								WHERE fact_vendedor = empl_codigo
								AND YEAR(fact_fecha) = (SELECT MAX(YEAR(fact_fecha)) FROM Factura)), 0)
    FROM Empleado

	select TOP 1 @mejorEmpleado = fact_vendedor from Factura
							group by fact_vendedor
							order by sum(fact_total) DESC
	
END
GO

BEGIN
declare @mejorEmpleado Int
exec dbo.Ej4Transact @mejorEmpleado output
print(@mejorEmpleado)
End

/* 9. Crear el/los objetos de base de datos que ante alguna modificación de un ítem de
factura de un artículo con composición realice el movimiento de sus
correspondientes componentes. */

select * from Item_Factura
select * from Composicion

create trigger ej9Transact on item_factura
AFTER UPDATE
as
BEGIN
	declare @cantidad numeric(6), @Producto numeric(6), @componente numeric(6)
	SELECT @Producto = item_producto FROM inserted
	Declare cursor_composicion CURSOR for 
	Select comp_componente, (i.item_cantidad - d.item_cantidad), i.item_producto from Composicion
	Join inserted i on comp_producto = i.item_producto join deleted d on comp_producto = d.item_producto 
	open cursor_composicion
	fetch next from cursor_composicion into @componente, @cantidad, @producto
	while @@FETCH_STATUS = 0
	BEGIN
		update STOCK
			set stoc_cantidad = stoc_cantidad - (@cantidad * (select comp_cantidad
												From Composicion 
												where comp_producto = @Producto))
			where stoc_producto = @componente
		fetch next from cursor_composicion 
		into @componente, @cantidad, @producto
	END
	CLOSE cursor_composicion;
    DEALLOCATE cursor_composicion;
END


/* 10. Crear el/los objetos de base de datos que ante el intento de borrar un artículo
verifique que no exista stock y si es así lo borre en caso contrario que emita un
mensaje de error.*/

Create trigger ej10Transact on Producto
Instead of Delete
as
begin
	IF EXISTS (
        SELECT 1
        From Stock s
		Join deleted d ON s.stoc_producto = d.prod_codigo
        GROUP BY d.prod_codigo
        HAVING SUM(s.stoc_cantidad) > 0
    )
	begin
		raiserror('no se puede realizar la operacion')
	end

	delete from STOCK where stoc_producto IN (SELECT prod_codigo from deleted)
	delete from Composicion where comp_producto IN (SELECT prod_codigo from deleted);
	delete from Producto where prod_codigo IN (select prod_codigo from deleted)
end

/* Ej 7 Hacer un procedimiento que dadas dos fechas complete la tabla Ventas. Debe
insertar una línea por cada artículo con los movimientos de stock generados por
las ventas entre esas fechas. La tabla se encuentra creada y vacía.*/

select * from item_factura
Create procedure ej7Transact @fechaDesde DATETIME, @fechaHasta DATETIME
AS
BEGIN
	 declare @renglon int, @producto char(8), @detalle char(50), @precio_prom numeric(12,4), @cantidad numeric(12,2), @ganancia numeric(12,2) 
	 declare cursorItem Cursor for
	 select @producto = prod_codigo, @detalle = prod_detalle, @cantidad = count(*), @precio_prom = avg(item_precio), @ganancia = sum(item_precio*item_cantidad)-sum(item_cantidad)*prod_precio
	 from item_factura
	 join Factura on item_tipo+item_sucursal+item_numero = fact_tipo+fact_sucursal+fact_numero
	 join Producto on item_producto = prod_codigo
	 where (fact_fecha > @fechaDesde and fact_fecha < @fechaHasta)
	 group by prod_codigo, prod_detalle, prod_precio
	 open cursorItem
	 fetch next from cursorItem
	 into @@producto, @detalle, @precio_prom, @cantidad, @ganancia
	 select renglon = 1
	 while @@FETCH_STATUS = 0
	 BEGIN
		insert ventas values (@producto, @detalle,  @cantidad, @precio_prom, @renglon, @ganancia)
		select @renglon = @renglon + 1
        fetch next into  @producto, @detalle,  @cantidad, @precio_prom, @ganancia
	 END
	 CLOSE cursorItem
	DEALLOCATE cursorItem
			
END

/* Mostrar para el o los artículos que tengan stock en todos los depósitos, nombre del
artículo, stock del depósito que más stock tiene. */

select * from stock

Create procedure ejRandomTransact 
AS
BEGIN
	declare @detalle char(50), @deposito char(6), @producto char(6)
	create c1 Cursor for
	select @detalle = prod_detalle, @deposito = (select	stoc_deposito
												From STOCK
												where stoc_producto = prod_codigo
												order by stoc_cantidad)
	From STOCK
	join Producto on stoc_producto = prod_codigo
	group by prod_detalle, prod_codigo
	having count(stoc_deposito) = (select count(*) FROM DEPOSITO)
	begin
		print(@detalle)
		print(@deposito)
END

/* 8. Realizar un procedimiento que complete la tabla Diferencias de precios, para los
productos facturados que tengan composición y en los cuales el precio de
facturación sea diferente al precio del cálculo de los precios unitarios por
cantidad de sus componentes, se aclara que un producto que compone a otro,
también puede estar compuesto por otros y así sucesivamente, la tabla se debe
crear y está formada por las siguientes columnas: */

select * from Composicion

Create Procedure ej8Transact 
AS 
BEGIN
	declare @codigo char(6), @detalle char(50), @cantidad Int, @precio_generado Int, @precio_facturado Int
	declare c1 Cursor for 
	select @codigo = prod_codigo, @detalle = prod_detalle, @precio_generado = (select sum(comp_cantidad * prod_precio)
																				from Composicion
																				join Producto p2 on prod_codigo = comp_componente
																				where comp_producto = prod_codigo), @precio_facturado = prod_precio
	From Composicion
	join Producto on comp_producto = prod_codigo
END

/* 11. Cree el/los objetos de base de datos necesarios para que dado un código de
empleado se retorne la cantidad de empleados que este tiene a su cargo (directa o
indirectamente). Solo contar aquellos empleados (directos o indirectos) que
tengan un código mayor que su jefe directo. */

select * from Empleado

create function ej11Transact (@empleadoJefe numeric(6))
Returns Int
As 
BEGIN
	declare @cantidadTotal Int, @empleado numeric(6)
	select @cantidadTotal = 0
	declare cursorEmpleados CURSOR FOR
	select empl_codigo From Empleado
	where empl_jefe = @empleadoJefe and (empl_codigo > @empleadoJefe)
	group by empl_codigo
	fetch cursorEmpleados into @empleado 
    while @@FETCH_STATUS = 0
	Begin
		select @cantidadTotal = @cantidadTotal + 1 + dbo.ej11Transact(@empleado)
		fetch cursorEmpleados into @empleado
	End
	close cursorEmpleados
	deallocate cursorEmpleados
	return @cantidadTotal
END
go

/* 12 Cree el/los objetos de base de datos necesarios para que nunca un producto
pueda ser compuesto por sí mismo. Se sabe que en la actualidad dicha regla se
cumple y que la base de datos es accedida por n aplicaciones de diferentes tipos
y tecnologías. No se conoce la cantidad de niveles de composición existentes.*/

create Trigger ej12trigger on Composicion for insert
as
BEGIN
	if exists (select * From inserted where dbo.ej12funcion(comp_producto) = 1)
	ROLLBACK
END

Create procedure ej12funcion (@producto numeric(6))
AS 
RETURNS INT
BEGIN
	if exists(select c1.comp_producto From composicion c1
		where c1.comp_producto = @producto and c1.comp_producto in (select c2.comp_componente FROM Composicion c2
									where comp_producto = c1.comp_producto))
	return 1

	return 0
END


/* PRACTICA PARCIAL:

1. Realizar una consulta SQL que retorne para el último año, los 5 vendedores con menos clientes asignados, 
que más vendieron en pesos (si hay varios con menos clientes asignados debe traer el que más vendió), solo deben 
considerarse las facturas que tengan más de dos ítems facturados:

1)	Apellido y Nombre  del Vendedor.
2)	Total de unidades de Producto Vendidas.
3)	Monto promedio de venta por factura.
4)	Monto total de ventas.

El resultado deberá mostrar ordenado la cantidad de ventas descendente, en caso de igualdad de cantidades, 
ordenar por código de vendedor.
NOTA: No se permite el uso de sub-selects en el FROM. */

Select top 5 empl_nombre, empl_apellido, sum(item_cantidad), avg(fact_total), sum(fact_total)
from Empleado 
join Factura f on f.fact_vendedor = empl_codigo
join item_factura on item_tipo+item_sucursal+item_numero = f.fact_tipo+f.fact_sucursal+f.fact_numero 
where year(f.fact_fecha) = (select max(year(fact_fecha)) From Factura)
And ((select count(*) From Item_Factura where item_tipo+item_sucursal+item_numero = f.fact_tipo+f.fact_sucursal+f.fact_numero) > 2)
group by empl_nombre, empl_apellido 
order by count(distinct f.fact_cliente) ASC, sum(f.fact_total) Desc, count(f.fact_tipo+f.fact_sucursal+f.fact_numero) desc 

/* CORRECCIONES:
El Monto total de ventas es item_cantidad * item_precio, porque suma varias veces si pones sum(fact_total). Error de desaprobacion
No hacer selects en el from (tipo un join tabla on item in select(...))
El top 5 estaria mal, lo que hay que hacer es una subconsulta del top 5 ordenado por clientes y ventas y pedir en el where que el empleado
se encuentre ahi
El filtrado de las facturas lo podes hacer en el join tambien con un and, para no traer todas las facturas del cliente. Si lo haces en
el where las traes todas y las filtras. Igual tecnicamente no habria mucha diferencia
*/


/* 2. Dado el contexto inflacionario se tiene que aplicar un control en el cual nunca se permita vender un producto a un 
precio que no esté entre 0%-5% del precio de venta del producto el mes anterior, ni tampoco que esté en más de un 50% el 
precio del mismo producto que hace 12 meses atrás. Aquellos productos nuevos, o que no tuvieron ventas en meses anteriores 
no debe considerar esta regla ya que no hay precio de referencia. */

Create trigger ejParcial2 on item_factura for Insert
AS
BEGIN
	if exists (select count(*) from inserted i
				join Factura f1 on i.item_tipo+i.item_sucursal+i.item_numero = fact_tipo+fact_sucursal+fact_numero
				where i.item_precio < (select item_precio from Item_Factura 
										join Factura f2 on i.item_tipo+i.item_sucursal+i.item_numero = f2.fact_tipo+f2.fact_sucursal+f2.fact_numero
										where MONTH(fact_fecha) = Month(DATEADD(month, -1, f1.fact_fecha)) * 1.05) 
				and i.item_precio < ((select item_precio from Item_Factura 
										join Factura f3 on i.item_tipo+i.item_sucursal+i.item_numero = f3.fact_tipo+f3.fact_sucursal+f3.fact_numero
										where year(f3.fact_fecha) = Year(DATEADD(year, -1, f1.fact_fecha))) * 1.50))
	rollback 
END
go

/*
CORRECCIONES: 
- El raiseerror te tira un rollback, es decir, corta la ejecucion.
- No se pueden updatear ni borrar facturas o item_factura
- Podias hacer una funcion que reciba la cantidad de meses para atras y calcule el precio. Solo le tenias que mandar 
el mes y el producto
- El cursor no deberia hacer falta con la funcion (de hecho mejor evitarlo), porque en el where los dos select son medio peruanos. Igual con la funcion podrias hacer
el select y que cumpla ambas condiciones
*/


select * from factura
select * from item_factura

/* 1.	Mostrar dos filas con los 2  empleados del mes: Estos son:

a)	El empleado que en el último año que haya ventas (en el cual se ejecuta la query) vendió 
más en dinero (fact_total)
b)	El segundo empleado del año, es aquel que en el mismo año (en el cual se ejecuta la query)
 tiene más facturas emitidas

Se deberá mostrar Apellido y nombre del empleado en una sola columna y para el primero
 un string que diga 
(Mejor Facturación y para el Segundo Vendió Más Facturas).

No se permiten sub select en el FROM.*/

select rtrim(e1.empl_apellido)+' '+rtrim(e1.empl_nombre) as Apellido_y_Nombre, 'Mejor Facturación' as Categoria
from Empleado e1
where e1.empl_codigo in (select top 1 empl_codigo from Empleado join Factura on fact_vendedor=empl_codigo
where YEAR(fact_fecha) = (SELECT TOP 1 YEAR(fact_fecha) FROM FACTURA ORDER BY FACT_FECHA DESC )
group by empl_codigo order by sum(fact_total) desc)

union

select rtrim(e2.empl_apellido)+' '+rtrim(e2.empl_nombre) as Apellido_y_Nombre, 'Vendió Más Facturas' as Categoria
from Empleado e2
where e2.empl_codigo in (select top 1 empl_codigo from Empleado join Factura on fact_vendedor=empl_codigo
where YEAR(fact_fecha) = (SELECT TOP 1 YEAR(fact_fecha) FROM FACTURA ORDER BY FACT_FECHA DESC )
group by empl_codigo order by count(distinct fact_tipo+fact_numero+fact_sucursal) desc)
go 
/* 
- como son dos universos disyuntivos, no lo puedo resolver en el from
- Aca el union no te lo toma porque no podes tener un order by en cada select, tenes que hacer un empl_codigo in (select top 1)
*/

/* 2.	Realizar un stored procedure que reciba un código de producto y una fecha y devuelva
 la mayor cantidad de días 
consecutivos a partir de esa fecha que el producto tuvo al menos la venta de una unidad en el día,
 el sistema de ventas 
on line está habilitado 24-7 por lo que se deben evaluar todos los días incluyendo domingos
 y feriados */

Create procedure ejParcialDias (@Producto numeric(6), @fechaInicio DateTime)
AS
BEGIN
	declare @cantidadASuperar Int = 0
	declare @cantidadActual Int = 0
	declare @fechaActual dateTime
	declare @fechaAnterior DateTime
	declare c1 Cursor for 
	select fact_fecha
			From Item_Factura
			Join Factura on item_tipo+item_sucursal+item_numero = fact_tipo+fact_sucursal+fact_numero
			where (item_producto = @Producto) and fact_fecha > @fechaInicio
			group by fact_fecha
			order by fact_fecha ASC
	fetch c1 into @fechaActual 
    while @@FETCH_STATUS = 0
	Begin
		if (@fechaAnterior = DATEADD(DAY, -1, @fechaActual))
			set @fechaAnterior = @fechaActual
			set @cantidadActual = @cantidadActual + 1
			fetch c1 into @fechaActual
		else
			if (@cantidadASuperar < @cantidadActual)
				set @cantidadASuperar = @cantidadActual
			set @fechaAnterior = @fechaActual
	END
	close c1
	deallocate c1
	Return @cantidadASuperar

END
go

/* 15. Cree el/los objetos de base de datos necesarios para que el objeto principal
reciba un producto como parametro y retorne el precio del mismo.
Se debe prever que el precio de los productos compuestos sera la sumatoria de
los componentes del mismo multiplicado por sus respectivas cantidades. No se
conocen los nivles de anidamiento posibles de los productos. Se asegura que
nunca un producto esta compuesto por si mismo a ningun nivel. El objeto
principal debe poder ser utilizado como filtro en el where de una sentencia
select.*/

Create FUNCTION ej15Transact (@producto numeric(6))
RETURNS Int
AS
BEGIN
	declare @precio Int = 0
	declare @componente numeric(6)
	declare @precioComponente Int
	if (@producto in (select comp_producto From Composicion))
	begin
		declare C1 cursor for select sum(comp_cantidad * prod_precio), comp_componente
		From Composicion join Producto on prod_codigo = comp_componente
		where comp_producto = @producto
		fetch next from c1 into @precioComponente, @componente
		while @@FETCH_STATUS = 0
		BEGIN
			if (@componente in (select comp_producto From Composicion))
				set @precio = @precio + dbo.ej15Transact(@componente)
			else
				set @precio = @precio + @precioComponente
			fetch next from c1 into @precioComponente, @componente
		END
		Close c1
		deallocate c1
		return @precio
		end
	 else 
		return (select prod_precio From producto)
END
GO

select * From Composicion

/* 16. Desarrolle el/los elementos de base de datos necesarios para que ante una venta
automaticamante se descuenten del stock los articulos vendidos. Se descontaran
del deposito que mas producto poseea y se supone que el stock se almacena
tanto de productos simples como compuestos (si se acaba el stock de los
compuestos no se arman combos)
En caso que no alcance el stock de un deposito se descontara del siguiente y asi
hasta agotar los depositos posibles. En ultima instancia se dejara stock negativo
en el ultimo deposito que se desconto. */

create trigger ej16Transact on Item_Factura on insert
As
BEGIN
	declare @deposito numeric(6)
	declare @producto numeric(6)
	set @producto = (select i.item_producto From inserted)
	set @deposito = (select top 1 stoc_deposito From STOCK
						stoc_producto = @producto
						order by stoc_cantidad)
	update Stock
	set stoc_cantidad = stoc_cantidad - i.item_cantidad
	where stoc_deposito = @deposito
END

/*
25. Desarrolle el/los elementos de base de datos necesarios para que no se permita
que la composición de los productos sea recursiva, o sea, que si el producto A
compone al producto B, dicho producto B no pueda ser compuesto por el
producto A, hoy la regla se cumple.
*/

Create Trigger ej25Transact on Composicion for insert, update
AS
BEGIN
	declare @componente numeric (6), @producto numeric (6)
	declare c1 cursor for select comp_producto, comp_componente From inserted
	open c1
	fetch next into @producto, @componente
	if (dbo.verificarComposicion(@componente, @producto) = 1)
		rollback
	else 
		fetch next into @producto, @componente
END

Create Function verificarComposicion (@producto numeric(6), @compuesto numeric(6))
Returns INT
AS
BEGIN
	if exists (select comp_producto
				From Composicion
				where comp_producto = @producto and comp_componente = @compuesto)
		return 1
	Else
		return 0
END
GO

/* 17. Sabiendo que el punto de reposicion del stock es la menor cantidad de ese objeto
que se debe almacenar en el deposito y que el stock maximo es la maxima
cantidad de ese producto en ese deposito, cree el/los objetos de base de datos
necesarios para que dicha regla de negocio se cumpla automaticamente. No se
conoce la forma de acceso a los datos ni el procedimiento por el cual se
incrementa o descuenta stock */

Create trigger ej17Transact on Stock for update, insert
AS
BEGIN
	declare @cantidad Int, @maximo char(8), @reposicion char(2)
	declare c1 cursor for 
	select stoc_cantidad, stoc_stock_maximo, stoc_punto_reposicion
	from inserted
	open c1 
	fetch next into @cantidad, @maximo, @reposicion
	while @@FETCH_STATUS = 0
	BEGIN
		if (@cantidad <  @reposicion) or (@cantidad > @maximo)
			rollback
	END
END

/* 18. Sabiendo que el limite de credito de un cliente es el monto maximo que se le
puede facturar mensualmente, cree el/los objetos de base de datos necesarios
para que dicha regla de negocio se cumpla automaticamente. No se conoce la
forma de acceso a los datos ni el procedimiento por el cual se emiten las facturas */

Create Trigger ej18Transact on factura for insert
AS
BEGIN
	if exists (select count(*) 
				From inserted
				Join Cliente on inserted.fact_cliente = clie_codigo
				where 
				((select sum(f2.fact_total) + (select inserted.fact_total)
					from factura f2
					where f2.fact_cliente = clie_codigo and Month(f2.fact_fecha) = Month(fact_fecha)) --aca falto el anio tambien
					+ inserted.fact_total) 
					> clie_limite_credito)
		begin
		Rollback
		end
END

/* 20. Crear el/los objeto/s necesarios para mantener actualizadas las comisiones del
vendedor.
El cálculo de la comisión está dado por el 5% de la venta total efectuada por ese
vendedor en ese mes, más un 3% adicional en caso de que ese vendedor haya
vendido por lo menos 50 productos distintos en el mes. */

select * from empleado
Create trigger ej20Transact on Factura for insert
AS
BEGIN
	declare @comisionNueva Int
	declare @ventaTotal Int
	select @ventaTotal = sum(f.fact_total) + inserted.fact_total
	From Factura f
	Join Inserted on f.fact_vendedor = inserted.fact_vendedor
	group by f.fact_vendedor
	if exists (select count(*)
				From Factura f2
				join inserted on f2.fact_vendedor = inserted.fact_vendedor
				join item_factura on item_tipo+item_numero+item_sucursal = f2.fact_tipo+f2.fact_numero+f2.fact_sucursal
				group by f2.fact_vendedor, Month(f2.fact_fecha)
				having count(distinct(item_producto)) > 50)
		begin
		update Empleado
		set empl_comision = @ventaTotal * 0.05
		where empl_codigo = (select inserted.fact_vendedor
								from inserted) 
		end
	else
		update Empleado
		set empl_comision = @ventaTotal * 0.03
		where empl_codigo = (select inserted.fact_vendedor
								from inserted) 
END


/*
Realizar el/los objetos de base de datos necesarios para que ante cada operación que se realice sobre la tabla STOCK, se grabe un registro 
en la tabla de auditoría AUD_STOCK con todas las columnas según se define a continuación. La tabla debe crearse y tendrá la siguiente estructura:
CREATE TABLE AUD_STOCK (
    auds_renglon bigint,
    auds_operacion char(3),
    auds_fecha_hora smalldatetime,
    auds_cantidad decimal(12,2),
    auds_punto_reposicion decimal(12,2),
    auds_stock_maximo decimal(12,2),
    auds_detalle char(100),
    auds_proxima_reposicion smalldatetime,
    auds_producto char(8),
    auds_deposito char(2)
);
Además de las columnas de la tabla STOCK, deberá grabarse lo siguiente:

- auds_renglon: Número consecutivo para cada registro que se grabe en AUD_STOCK.
- auds_operacion: Si se insertó un registro en STOCK, debe grabar "INS". Si se borró, "DEL", y si se actualizó algún campo, deberá 
grabar "UP1" y los valores anteriores, y en otro registro "UP2" con los valores nuevos en el resto de los campos.
- auds_fecha_hora: Fecha y hora de la operación.
*/

create trigger ejParcialTransact on Stock for insert,update
AS
BEGIN
	set @renglon = 0
	declare @stock_maximo decimal(12,2), @cantidad decimal(12,2), @fecha_hora smalldatetime, @punto_reposicion decimal(12,2), @detalle char(100),
	@proxima_reposicion smalldatetime, @producto char(8), @deposito char(2), @renglon BIGINT
	if exists (select count(*) from deleted) -- inserto
	Begin
		declare c1 cursor for 
		select @stock_maximo = i.stoc_stock_maximo, @cantidad = i.stoc_cantidad, @fecha_hora = TODATETIMEOFFSET, @punto_reposicion = i.stoc_punto_reposicion
		, @detalle = prod_detalle, @producto = prod_codigo, @deposito = i.stoc_deposito, @proxima_reposicion = i.stoc_proxima_reposicion
		From inserted
		join producto on stoc_producto = prod_codigo
		open c1 fetch next into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion
		, @detalle, @producto, @deposito, @proxima_reposicion
		Begin
		insert into dbo.AUD_STOCK values(
		(@renglon +1),
		'INS',
		@fecha_hora,
		@cantidad,
		@punto_reposicion,
		@stock_maximo,
		@detalle,
		@proxima_reposicion,
		@producto,
		@detalle
		)
		fetch next from c1 into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion 
		End
		close c1
		deallocate c1
	end

	else -- updateo o deleteo
		if exists (select * from inserted) -- updateo
		Begin
		declare c1 cursor for 
		select @stock_maximo = i.stoc_stock_maximo, @cantidad = i.stoc_cantidad, @fecha_hora = TODATETIMEOFFSET, @punto_reposicion = i.stoc_punto_reposicion
		, @detalle = prod_detalle, @producto = prod_codigo, @deposito = i.stoc_deposito, @proxima_reposicion = i.stoc_proxima_reposicion
		From inserted
		join producto on stoc_producto = prod_codigo
		open c1 fetch next into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion
		, @detalle, @producto, @deposito, @proxima_reposicion
		Begin
		insert into dbo.AUD_STOCK values(
		(@renglon +1),
		'UP2',
		@fecha_hora,
		@cantidad,
		@punto_reposicion,
		@stock_maximo,
		@detalle,
		@proxima_reposicion,
		@producto,
		@detalle
		)
		fetch next from c1 into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion 
		end
		close c1
		deallocate c1
		set @renglon = 0
		declare c2 cursor for 
		select @stock_maximo = i.stoc_stock_maximo, @cantidad = i.stoc_cantidad, @fecha_hora = TODATETIMEOFFSET, @punto_reposicion = i.stoc_punto_reposicion
		, @detalle = prod_detalle, @producto = prod_codigo, @deposito = i.stoc_deposito, @proxima_reposicion = i.stoc_proxima_reposicion
		From deleted
		join producto on stoc_producto = prod_codigo
		open c2 
		fetch next from c2 into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion
		, @detalle, @producto, @deposito, @proxima_reposicion
		Begin
		insert into dbo.AUD_STOCK values(
		(@renglon + 1),
		'UP2',
		@fecha_hora,
		@cantidad,
		@punto_reposicion,
		@stock_maximo,
		@detalle,
		@proxima_reposicion,
		@producto,
		@detalle
		)
		fetch next from c2 into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion 
		end
		close c2
		deallocate c2
		End
		else -- deleteo
			Begin
				declare c1 cursor for 
				select @stock_maximo = d.stoc_stock_maximo, @cantidad = d.stoc_cantidad, @fecha_hora = TODATETIMEOFFSET, @punto_reposicion = d.stoc_punto_reposicion
				, @detalle = prod_detalle, @producto = prod_codigo, @deposito = d.stoc_deposito, @proxima_reposicion = d.stoc_proxima_reposicion
				From deleted
				join producto on stoc_producto = prod_codigo
				open c1 fetch next into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion
				, @detalle, @producto, @deposito, @proxima_reposicion
				Begin
				insert into dbo.AUD_STOCK values(
				(@renglon +1),
				'DEL',
				@fecha_hora,
				@cantidad,
				@punto_reposicion,
				@stock_maximo,
				@detalle,
				@proxima_reposicion,
				@producto,
				@detalle
				)
				fetch next from c1 into @stock_maximo, @cantidad, @fecha_hora, @punto_reposicion 
				End
				close c1
				deallocate c1
			end

END



CREATE TABLE AUD_STOCK (
    auds_renglon bigint,
    auds_operacion char(3),
    auds_fecha_hora smalldatetime,
    auds_cantidad decimal(12,2),
    auds_punto_reposicion decimal(12,2),
    auds_stock_maximo decimal(12,2),
    auds_detalle char(100),
    auds_proxima_reposicion smalldatetime,
    auds_producto char(8),
    auds_deposito char(2))



